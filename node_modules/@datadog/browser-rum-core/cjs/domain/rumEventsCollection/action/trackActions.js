"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.trackActions = exports.ACTION_CONTEXT_TIME_OUT_DELAY = exports.AUTO_ACTION_MAX_DURATION = void 0;
var browser_core_1 = require("@datadog/browser-core");
var trackEventCounts_1 = require("../../trackEventCounts");
var waitIdlePage_1 = require("../../waitIdlePage");
var getActionNameFromElement_1 = require("./getActionNameFromElement");
// Maximum duration for automatic actions
exports.AUTO_ACTION_MAX_DURATION = 10 * browser_core_1.ONE_SECOND;
exports.ACTION_CONTEXT_TIME_OUT_DELAY = 5 * browser_core_1.ONE_MINUTE; // arbitrary
function trackActions(lifeCycle, domMutationObservable, _a) {
    var actionNameAttribute = _a.actionNameAttribute;
    var history = new browser_core_1.ContextHistory(exports.ACTION_CONTEXT_TIME_OUT_DELAY);
    lifeCycle.subscribe(8 /* SESSION_RENEWED */, function () {
        history.reset();
    });
    var stopListener = listenEvents(function (event) {
        if (!(0, browser_core_1.isExperimentalFeatureEnabled)('frustration-signals') && history.find()) {
            // Ignore any new action if another one is already occurring.
            return;
        }
        var name = (0, getActionNameFromElement_1.getActionNameFromElement)(event.target, actionNameAttribute);
        if (!name) {
            return;
        }
        var actionController = newAction(lifeCycle, domMutationObservable, "click" /* CLICK */, name, event, function (endTime) {
            historyEntry.close((0, browser_core_1.getRelativeTime)(endTime));
        }, function () {
            historyEntry.remove();
        });
        var historyEntry = history.add(actionController, actionController.startClocks.relative);
    }).stop;
    var actionContexts = {
        findActionId: function (startTime) {
            var _a;
            return (0, browser_core_1.isExperimentalFeatureEnabled)('frustration-signals')
                ? history.findAll(startTime).map(function (controller) { return controller.id; })
                : (_a = history.find(startTime)) === null || _a === void 0 ? void 0 : _a.id;
        },
    };
    return {
        stop: function () {
            history.findAll().forEach(function (actionController) { return actionController.discard(); });
            stopListener();
        },
        actionContexts: actionContexts,
    };
}
exports.trackActions = trackActions;
function listenEvents(callback) {
    return (0, browser_core_1.addEventListener)(window, "click" /* CLICK */, function (event) {
        if (event.target instanceof Element) {
            callback(event);
        }
    }, { capture: true });
}
function newAction(lifeCycle, domMutationObservable, type, name, event, onCompleteCallback, onDiscardCallback) {
    var id = (0, browser_core_1.generateUUID)();
    var startClocks = (0, browser_core_1.clocksNow)();
    var eventCountsSubscription = (0, trackEventCounts_1.trackEventCounts)(lifeCycle);
    var stopWaitingIdlePage = (0, waitIdlePage_1.waitIdlePage)(lifeCycle, domMutationObservable, function (idleEvent) {
        if (idleEvent.hadActivity && startClocks.timeStamp <= idleEvent.end) {
            complete(idleEvent.end);
        }
        else {
            discard();
        }
    }, exports.AUTO_ACTION_MAX_DURATION).stop;
    var viewCreatedSubscription;
    if (!(0, browser_core_1.isExperimentalFeatureEnabled)('frustration-signals')) {
        // New views trigger the discard of the current pending Action
        viewCreatedSubscription = lifeCycle.subscribe(2 /* VIEW_CREATED */, discard);
    }
    function complete(endTime) {
        cleanup();
        var eventCounts = eventCountsSubscription.eventCounts;
        lifeCycle.notify(1 /* AUTO_ACTION_COMPLETED */, {
            counts: {
                errorCount: eventCounts.errorCount,
                longTaskCount: eventCounts.longTaskCount,
                resourceCount: eventCounts.resourceCount,
            },
            duration: (0, browser_core_1.elapsed)(startClocks.timeStamp, endTime),
            id: id,
            name: name,
            startClocks: startClocks,
            type: type,
            event: event,
        });
        onCompleteCallback(endTime);
    }
    function discard() {
        cleanup();
        onDiscardCallback();
    }
    function cleanup() {
        stopWaitingIdlePage();
        eventCountsSubscription.stop();
        if (viewCreatedSubscription) {
            viewCreatedSubscription.unsubscribe();
        }
    }
    return {
        discard: discard,
        id: id,
        startClocks: startClocks,
    };
}
//# sourceMappingURL=trackActions.js.map